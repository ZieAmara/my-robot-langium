/******************************************************************************
 * This file was generated by langium-cli 2.0.1.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const MyRobotTerminals = {
    ID: /(\^?(([a-z]|[A-Z])|_)((([a-z]|[A-Z])|_)|[0-9])*)/,
    STRING: /(("((\\([\s\S]))|((?!(\\|"))[\s\S]*?))*")|('((\\([\s\S]))|((?!(\\|'))[\s\S]*?))*'))/,
    ML_COMMENT: /(\/\*([\s\S]*?\*\/))/,
    SL_COMMENT: /(\/\/((?!(\n|\r))[\s\S]*?)(\r?\n)?)/,
    WS: /((( |	)|\r)|\n)+/,
};

export type EString = string;

export function isEString(item: unknown): item is EString {
    return (typeof item === 'string' && (/(("((\\([\s\S]))|((?!(\\|"))[\s\S]*?))*")|('((\\([\s\S]))|((?!(\\|'))[\s\S]*?))*'))/.test(item) || /(\^?(([a-z]|[A-Z])|_)((([a-z]|[A-Z])|_)|[0-9])*)/.test(item)));
}

export type ID = string;

export type Type = Type_boolean | Type_number;

export type Type_boolean = 'boolean';

export type Type_number = 'number';

export type Unit = Unit_cm | Unit_m | Unit_mm;

export type Unit_cm = 'cm';

export type Unit_m = 'm';

export type Unit_mm = 'mm';

export interface AddSubOperator extends AstNode {
    readonly $type: 'Add' | 'AddSubOperator' | 'Sub';
}

export const AddSubOperator = 'AddSubOperator';

export function isAddSubOperator(item: unknown): item is AddSubOperator {
    return reflection.isInstance(item, AddSubOperator);
}

export interface BooleanOperator extends AstNode {
    readonly $type: 'BooleanOperator' | 'EqualTo' | 'LowerThan' | 'UpperThan';
}

export const BooleanOperator = 'BooleanOperator';

export function isBooleanOperator(item: unknown): item is BooleanOperator {
    return reflection.isInstance(item, BooleanOperator);
}

export interface Expression extends AstNode {
    readonly $type: 'AddSubExpression' | 'ArithmeticExpression' | 'BooleanExpression' | 'CallEntity' | 'CallFunctionExpr' | 'Expression' | 'GetSensor' | 'MultiDivExpression' | 'UnaryExpression' | 'Value';
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface Fonction extends AstNode {
    readonly $container: Program;
    readonly $type: 'Fonction';
    body: Array<Statement>
    name: ID
    parameter: Array<Parameter>
    returntype?: ReturnType
}

export const Fonction = 'Fonction';

export function isFonction(item: unknown): item is Fonction {
    return reflection.isInstance(item, Fonction);
}

export interface MultiDivOperator extends AstNode {
    readonly $type: 'Divise' | 'MultiDivOperator' | 'Multiply';
}

export const MultiDivOperator = 'MultiDivOperator';

export function isMultiDivOperator(item: unknown): item is MultiDivOperator {
    return reflection.isInstance(item, MultiDivOperator);
}

export interface Program extends AstNode {
    readonly $type: 'Program';
    function: Array<Fonction>
    name?: string
}

export const Program = 'Program';

export function isProgram(item: unknown): item is Program {
    return reflection.isInstance(item, Program);
}

export interface ReturnType extends AstNode {
    readonly $container: Fonction;
    readonly $type: 'ReturnType';
    type: 'void' | Type
}

export const ReturnType = 'ReturnType';

export function isReturnType(item: unknown): item is ReturnType {
    return reflection.isInstance(item, ReturnType);
}

export interface Statement extends AstNode {
    readonly $type: 'Backward' | 'CallFunction' | 'Clock' | 'ClockLeft' | 'ControlRobot' | 'ControlStructure' | 'Entity' | 'Forward' | 'If' | 'Left' | 'Loop' | 'Movement' | 'Parameter' | 'Right' | 'Rotate' | 'SetSpeed' | 'Statement' | 'VariableAssignation' | 'VariableStatement';
}

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export interface Add extends AddSubOperator {
    readonly $type: 'Add';
}

export const Add = 'Add';

export function isAdd(item: unknown): item is Add {
    return reflection.isInstance(item, Add);
}

export interface Sub extends AddSubOperator {
    readonly $type: 'Sub';
}

export const Sub = 'Sub';

export function isSub(item: unknown): item is Sub {
    return reflection.isInstance(item, Sub);
}

export interface EqualTo extends BooleanOperator {
    readonly $type: 'EqualTo';
}

export const EqualTo = 'EqualTo';

export function isEqualTo(item: unknown): item is EqualTo {
    return reflection.isInstance(item, EqualTo);
}

export interface LowerThan extends BooleanOperator {
    readonly $type: 'LowerThan';
}

export const LowerThan = 'LowerThan';

export function isLowerThan(item: unknown): item is LowerThan {
    return reflection.isInstance(item, LowerThan);
}

export interface UpperThan extends BooleanOperator {
    readonly $type: 'UpperThan';
}

export const UpperThan = 'UpperThan';

export function isUpperThan(item: unknown): item is UpperThan {
    return reflection.isInstance(item, UpperThan);
}

export interface ArithmeticExpression extends Expression {
    readonly $type: 'AddSubExpression' | 'ArithmeticExpression' | 'MultiDivExpression';
    arithmeticexpression: Array<ArithmeticExpression>
    leftOperand: UnaryExpression
    rightOperand: Array<UnaryExpression>
}

export const ArithmeticExpression = 'ArithmeticExpression';

export function isArithmeticExpression(item: unknown): item is ArithmeticExpression {
    return reflection.isInstance(item, ArithmeticExpression);
}

export interface BooleanExpression extends Expression {
    readonly $container: ControlStructure;
    readonly $type: 'BooleanExpression';
    leftCondition: Expression
    operator: BooleanOperator
    rightCondition: Expression
}

export const BooleanExpression = 'BooleanExpression';

export function isBooleanExpression(item: unknown): item is BooleanExpression {
    return reflection.isInstance(item, BooleanExpression);
}

export interface UnaryExpression extends Expression {
    readonly $type: 'CallEntity' | 'CallFunctionExpr' | 'GetSensor' | 'UnaryExpression' | 'Value';
}

export const UnaryExpression = 'UnaryExpression';

export function isUnaryExpression(item: unknown): item is UnaryExpression {
    return reflection.isInstance(item, UnaryExpression);
}

export interface Divise extends MultiDivOperator {
    readonly $type: 'Divise';
}

export const Divise = 'Divise';

export function isDivise(item: unknown): item is Divise {
    return reflection.isInstance(item, Divise);
}

export interface Multiply extends MultiDivOperator {
    readonly $type: 'Multiply';
}

export const Multiply = 'Multiply';

export function isMultiply(item: unknown): item is Multiply {
    return reflection.isInstance(item, Multiply);
}

export interface CallFunction extends Statement {
    readonly $type: 'CallFunction';
    arguments: Array<Expression>
    function: Reference<Fonction>
}

export const CallFunction = 'CallFunction';

export function isCallFunction(item: unknown): item is CallFunction {
    return reflection.isInstance(item, CallFunction);
}

export interface ControlRobot extends Statement {
    readonly $type: 'Backward' | 'Clock' | 'ClockLeft' | 'ControlRobot' | 'Forward' | 'Left' | 'Movement' | 'Right' | 'Rotate';
}

export const ControlRobot = 'ControlRobot';

export function isControlRobot(item: unknown): item is ControlRobot {
    return reflection.isInstance(item, ControlRobot);
}

export interface ControlStructure extends Statement {
    readonly $type: 'ControlStructure' | 'If' | 'Loop';
    condition: Array<BooleanExpression>
    expression: Array<Expression>
}

export const ControlStructure = 'ControlStructure';

export function isControlStructure(item: unknown): item is ControlStructure {
    return reflection.isInstance(item, ControlStructure);
}

export interface Entity extends Statement {
    readonly $type: 'Entity' | 'Parameter' | 'VariableStatement';
    value?: Expression
}

export const Entity = 'Entity';

export function isEntity(item: unknown): item is Entity {
    return reflection.isInstance(item, Entity);
}

export interface SetSpeed extends Statement {
    readonly $type: 'SetSpeed';
    distance: Expression
    unit: Unit
}

export const SetSpeed = 'SetSpeed';

export function isSetSpeed(item: unknown): item is SetSpeed {
    return reflection.isInstance(item, SetSpeed);
}

export interface VariableAssignation extends Statement {
    readonly $type: 'VariableAssignation';
    value?: Expression
    variable: Reference<VariableStatement>
}

export const VariableAssignation = 'VariableAssignation';

export function isVariableAssignation(item: unknown): item is VariableAssignation {
    return reflection.isInstance(item, VariableAssignation);
}

export interface AddSubExpression extends ArithmeticExpression {
    readonly $type: 'AddSubExpression';
    operator: Array<AddSubOperator>
}

export const AddSubExpression = 'AddSubExpression';

export function isAddSubExpression(item: unknown): item is AddSubExpression {
    return reflection.isInstance(item, AddSubExpression);
}

export interface MultiDivExpression extends ArithmeticExpression {
    readonly $type: 'MultiDivExpression';
    operator: Array<MultiDivOperator>
}

export const MultiDivExpression = 'MultiDivExpression';

export function isMultiDivExpression(item: unknown): item is MultiDivExpression {
    return reflection.isInstance(item, MultiDivExpression);
}

export interface CallEntity extends UnaryExpression {
    readonly $type: 'CallEntity';
    entity: Reference<Entity>
}

export const CallEntity = 'CallEntity';

export function isCallEntity(item: unknown): item is CallEntity {
    return reflection.isInstance(item, CallEntity);
}

export interface CallFunctionExpr extends UnaryExpression {
    readonly $type: 'CallFunctionExpr';
    arguments: Array<Expression>
    function: Reference<Fonction>
}

export const CallFunctionExpr = 'CallFunctionExpr';

export function isCallFunctionExpr(item: unknown): item is CallFunctionExpr {
    return reflection.isInstance(item, CallFunctionExpr);
}

export interface GetSensor extends UnaryExpression {
    readonly $type: 'GetSensor';
}

export const GetSensor = 'GetSensor';

export function isGetSensor(item: unknown): item is GetSensor {
    return reflection.isInstance(item, GetSensor);
}

export interface Value extends UnaryExpression {
    readonly $type: 'Value';
}

export const Value = 'Value';

export function isValue(item: unknown): item is Value {
    return reflection.isInstance(item, Value);
}

export interface Movement extends ControlRobot {
    readonly $type: 'Backward' | 'Forward' | 'Left' | 'Movement' | 'Right';
    distance?: Expression
    unit: Unit
}

export const Movement = 'Movement';

export function isMovement(item: unknown): item is Movement {
    return reflection.isInstance(item, Movement);
}

export interface Rotate extends ControlRobot {
    readonly $type: 'Clock' | 'ClockLeft' | 'Rotate';
    angle?: Expression
}

export const Rotate = 'Rotate';

export function isRotate(item: unknown): item is Rotate {
    return reflection.isInstance(item, Rotate);
}

export interface If extends ControlStructure {
    readonly $type: 'If';
    else: Array<Statement>
    then: Array<Statement>
}

export const If = 'If';

export function isIf(item: unknown): item is If {
    return reflection.isInstance(item, If);
}

export interface Loop extends ControlStructure {
    readonly $type: 'Loop';
    body: Array<Statement>
}

export const Loop = 'Loop';

export function isLoop(item: unknown): item is Loop {
    return reflection.isInstance(item, Loop);
}

export interface Parameter extends Entity {
    readonly $container: Fonction;
    readonly $type: 'Parameter';
    name: ID
    type: Type
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface VariableStatement extends Entity {
    readonly $type: 'VariableStatement';
    name: ID
    type: Type
}

export const VariableStatement = 'VariableStatement';

export function isVariableStatement(item: unknown): item is VariableStatement {
    return reflection.isInstance(item, VariableStatement);
}

export interface Backward extends Movement {
    readonly $type: 'Backward';
}

export const Backward = 'Backward';

export function isBackward(item: unknown): item is Backward {
    return reflection.isInstance(item, Backward);
}

export interface Forward extends Movement {
    readonly $type: 'Forward';
}

export const Forward = 'Forward';

export function isForward(item: unknown): item is Forward {
    return reflection.isInstance(item, Forward);
}

export interface Left extends Movement {
    readonly $type: 'Left';
}

export const Left = 'Left';

export function isLeft(item: unknown): item is Left {
    return reflection.isInstance(item, Left);
}

export interface Right extends Movement {
    readonly $type: 'Right';
}

export const Right = 'Right';

export function isRight(item: unknown): item is Right {
    return reflection.isInstance(item, Right);
}

export interface Clock extends Rotate {
    readonly $type: 'Clock';
}

export const Clock = 'Clock';

export function isClock(item: unknown): item is Clock {
    return reflection.isInstance(item, Clock);
}

export interface ClockLeft extends Rotate {
    readonly $type: 'ClockLeft';
}

export const ClockLeft = 'ClockLeft';

export function isClockLeft(item: unknown): item is ClockLeft {
    return reflection.isInstance(item, ClockLeft);
}

export type MyRobotAstType = {
    Add: Add
    AddSubExpression: AddSubExpression
    AddSubOperator: AddSubOperator
    ArithmeticExpression: ArithmeticExpression
    Backward: Backward
    BooleanExpression: BooleanExpression
    BooleanOperator: BooleanOperator
    CallEntity: CallEntity
    CallFunction: CallFunction
    CallFunctionExpr: CallFunctionExpr
    Clock: Clock
    ClockLeft: ClockLeft
    ControlRobot: ControlRobot
    ControlStructure: ControlStructure
    Divise: Divise
    Entity: Entity
    EqualTo: EqualTo
    Expression: Expression
    Fonction: Fonction
    Forward: Forward
    GetSensor: GetSensor
    If: If
    Left: Left
    Loop: Loop
    LowerThan: LowerThan
    Movement: Movement
    MultiDivExpression: MultiDivExpression
    MultiDivOperator: MultiDivOperator
    Multiply: Multiply
    Parameter: Parameter
    Program: Program
    ReturnType: ReturnType
    Right: Right
    Rotate: Rotate
    SetSpeed: SetSpeed
    Statement: Statement
    Sub: Sub
    UnaryExpression: UnaryExpression
    UpperThan: UpperThan
    Value: Value
    VariableAssignation: VariableAssignation
    VariableStatement: VariableStatement
}

export class MyRobotAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['Add', 'AddSubExpression', 'AddSubOperator', 'ArithmeticExpression', 'Backward', 'BooleanExpression', 'BooleanOperator', 'CallEntity', 'CallFunction', 'CallFunctionExpr', 'Clock', 'ClockLeft', 'ControlRobot', 'ControlStructure', 'Divise', 'Entity', 'EqualTo', 'Expression', 'Fonction', 'Forward', 'GetSensor', 'If', 'Left', 'Loop', 'LowerThan', 'Movement', 'MultiDivExpression', 'MultiDivOperator', 'Multiply', 'Parameter', 'Program', 'ReturnType', 'Right', 'Rotate', 'SetSpeed', 'Statement', 'Sub', 'UnaryExpression', 'UpperThan', 'Value', 'VariableAssignation', 'VariableStatement'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Add:
            case Sub: {
                return this.isSubtype(AddSubOperator, supertype);
            }
            case AddSubExpression:
            case MultiDivExpression: {
                return this.isSubtype(ArithmeticExpression, supertype);
            }
            case ArithmeticExpression:
            case BooleanExpression:
            case UnaryExpression: {
                return this.isSubtype(Expression, supertype);
            }
            case Backward:
            case Forward:
            case Left:
            case Right: {
                return this.isSubtype(Movement, supertype);
            }
            case CallEntity:
            case CallFunctionExpr:
            case GetSensor:
            case Value: {
                return this.isSubtype(UnaryExpression, supertype);
            }
            case CallFunction:
            case ControlRobot:
            case ControlStructure:
            case Entity:
            case SetSpeed:
            case VariableAssignation: {
                return this.isSubtype(Statement, supertype);
            }
            case Clock:
            case ClockLeft: {
                return this.isSubtype(Rotate, supertype);
            }
            case Divise:
            case Multiply: {
                return this.isSubtype(MultiDivOperator, supertype);
            }
            case EqualTo:
            case LowerThan:
            case UpperThan: {
                return this.isSubtype(BooleanOperator, supertype);
            }
            case If:
            case Loop: {
                return this.isSubtype(ControlStructure, supertype);
            }
            case Movement:
            case Rotate: {
                return this.isSubtype(ControlRobot, supertype);
            }
            case Parameter:
            case VariableStatement: {
                return this.isSubtype(Entity, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'CallEntity:entity': {
                return Entity;
            }
            case 'CallFunction:function':
            case 'CallFunctionExpr:function': {
                return Fonction;
            }
            case 'VariableAssignation:variable': {
                return VariableStatement;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Fonction': {
                return {
                    name: 'Fonction',
                    mandatory: [
                        { name: 'body', type: 'array' },
                        { name: 'parameter', type: 'array' }
                    ]
                };
            }
            case 'Program': {
                return {
                    name: 'Program',
                    mandatory: [
                        { name: 'function', type: 'array' }
                    ]
                };
            }
            case 'ArithmeticExpression': {
                return {
                    name: 'ArithmeticExpression',
                    mandatory: [
                        { name: 'arithmeticexpression', type: 'array' },
                        { name: 'rightOperand', type: 'array' }
                    ]
                };
            }
            case 'CallFunction': {
                return {
                    name: 'CallFunction',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'ControlStructure': {
                return {
                    name: 'ControlStructure',
                    mandatory: [
                        { name: 'condition', type: 'array' },
                        { name: 'expression', type: 'array' }
                    ]
                };
            }
            case 'AddSubExpression': {
                return {
                    name: 'AddSubExpression',
                    mandatory: [
                        { name: 'operator', type: 'array' }
                    ]
                };
            }
            case 'MultiDivExpression': {
                return {
                    name: 'MultiDivExpression',
                    mandatory: [
                        { name: 'operator', type: 'array' }
                    ]
                };
            }
            case 'CallFunctionExpr': {
                return {
                    name: 'CallFunctionExpr',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'If': {
                return {
                    name: 'If',
                    mandatory: [
                        { name: 'else', type: 'array' },
                        { name: 'then', type: 'array' }
                    ]
                };
            }
            case 'Loop': {
                return {
                    name: 'Loop',
                    mandatory: [
                        { name: 'body', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new MyRobotAstReflection();
