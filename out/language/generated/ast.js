/******************************************************************************
 * This file was generated by langium-cli 2.0.1.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
import { AbstractAstReflection } from 'langium';
export const MyRobotTerminals = {
    ID: /(\^?(([a-z]|[A-Z])|_)((([a-z]|[A-Z])|_)|[0-9])*)/,
    INT: /[0-9]+/,
    STRING: /(("((\\([\s\S]))|((?!(\\|"))[\s\S]*?))*")|('((\\([\s\S]))|((?!(\\|'))[\s\S]*?))*'))/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};
export function isEString(item) {
    return (typeof item === 'string' && (/(("((\\([\s\S]))|((?!(\\|"))[\s\S]*?))*")|('((\\([\s\S]))|((?!(\\|'))[\s\S]*?))*'))/.test(item) || /(\^?(([a-z]|[A-Z])|_)((([a-z]|[A-Z])|_)|[0-9])*)/.test(item)));
}
export const AddSubOperator = 'AddSubOperator';
export function isAddSubOperator(item) {
    return reflection.isInstance(item, AddSubOperator);
}
export const BooleanExpression = 'BooleanExpression';
export function isBooleanExpression(item) {
    return reflection.isInstance(item, BooleanExpression);
}
export const BooleanOperator = 'BooleanOperator';
export function isBooleanOperator(item) {
    return reflection.isInstance(item, BooleanOperator);
}
export const Expression = 'Expression';
export function isExpression(item) {
    return reflection.isInstance(item, Expression);
}
export const Fonction = 'Fonction';
export function isFonction(item) {
    return reflection.isInstance(item, Fonction);
}
export const MultiDivExpression = 'MultiDivExpression';
export function isMultiDivExpression(item) {
    return reflection.isInstance(item, MultiDivExpression);
}
export const MultiDivOperator = 'MultiDivOperator';
export function isMultiDivOperator(item) {
    return reflection.isInstance(item, MultiDivOperator);
}
export const Program = 'Program';
export function isProgram(item) {
    return reflection.isInstance(item, Program);
}
export const ReturnType = 'ReturnType';
export function isReturnType(item) {
    return reflection.isInstance(item, ReturnType);
}
export const Statement = 'Statement';
export function isStatement(item) {
    return reflection.isInstance(item, Statement);
}
export const Add = 'Add';
export function isAdd(item) {
    return reflection.isInstance(item, Add);
}
export const Sub = 'Sub';
export function isSub(item) {
    return reflection.isInstance(item, Sub);
}
export const And = 'And';
export function isAnd(item) {
    return reflection.isInstance(item, And);
}
export const EqualTo = 'EqualTo';
export function isEqualTo(item) {
    return reflection.isInstance(item, EqualTo);
}
export const LowerOrEqualTo = 'LowerOrEqualTo';
export function isLowerOrEqualTo(item) {
    return reflection.isInstance(item, LowerOrEqualTo);
}
export const LowerThan = 'LowerThan';
export function isLowerThan(item) {
    return reflection.isInstance(item, LowerThan);
}
export const Not = 'Not';
export function isNot(item) {
    return reflection.isInstance(item, Not);
}
export const Or = 'Or';
export function isOr(item) {
    return reflection.isInstance(item, Or);
}
export const UpperOrEqualTo = 'UpperOrEqualTo';
export function isUpperOrEqualTo(item) {
    return reflection.isInstance(item, UpperOrEqualTo);
}
export const UpperThan = 'UpperThan';
export function isUpperThan(item) {
    return reflection.isInstance(item, UpperThan);
}
export const ArithmeticExpression = 'ArithmeticExpression';
export function isArithmeticExpression(item) {
    return reflection.isInstance(item, ArithmeticExpression);
}
export const UnaryExpression = 'UnaryExpression';
export function isUnaryExpression(item) {
    return reflection.isInstance(item, UnaryExpression);
}
export const Divise = 'Divise';
export function isDivise(item) {
    return reflection.isInstance(item, Divise);
}
export const Multiply = 'Multiply';
export function isMultiply(item) {
    return reflection.isInstance(item, Multiply);
}
export const CallFunction = 'CallFunction';
export function isCallFunction(item) {
    return reflection.isInstance(item, CallFunction);
}
export const ControlRobot = 'ControlRobot';
export function isControlRobot(item) {
    return reflection.isInstance(item, ControlRobot);
}
export const ControlStructure = 'ControlStructure';
export function isControlStructure(item) {
    return reflection.isInstance(item, ControlStructure);
}
export const Entity = 'Entity';
export function isEntity(item) {
    return reflection.isInstance(item, Entity);
}
export const SetSpeed = 'SetSpeed';
export function isSetSpeed(item) {
    return reflection.isInstance(item, SetSpeed);
}
export const VariableAssignation = 'VariableAssignation';
export function isVariableAssignation(item) {
    return reflection.isInstance(item, VariableAssignation);
}
export const AddSubExpression = 'AddSubExpression';
export function isAddSubExpression(item) {
    return reflection.isInstance(item, AddSubExpression);
}
export const CallEntity = 'CallEntity';
export function isCallEntity(item) {
    return reflection.isInstance(item, CallEntity);
}
export const CallFunctionExpr = 'CallFunctionExpr';
export function isCallFunctionExpr(item) {
    return reflection.isInstance(item, CallFunctionExpr);
}
export const GetSensor = 'GetSensor';
export function isGetSensor(item) {
    return reflection.isInstance(item, GetSensor);
}
export const Value = 'Value';
export function isValue(item) {
    return reflection.isInstance(item, Value);
}
export const Movement = 'Movement';
export function isMovement(item) {
    return reflection.isInstance(item, Movement);
}
export const Rotate = 'Rotate';
export function isRotate(item) {
    return reflection.isInstance(item, Rotate);
}
export const If = 'If';
export function isIf(item) {
    return reflection.isInstance(item, If);
}
export const Loop = 'Loop';
export function isLoop(item) {
    return reflection.isInstance(item, Loop);
}
export const Parameter = 'Parameter';
export function isParameter(item) {
    return reflection.isInstance(item, Parameter);
}
export const VariableStatement = 'VariableStatement';
export function isVariableStatement(item) {
    return reflection.isInstance(item, VariableStatement);
}
export const Backward = 'Backward';
export function isBackward(item) {
    return reflection.isInstance(item, Backward);
}
export const Forward = 'Forward';
export function isForward(item) {
    return reflection.isInstance(item, Forward);
}
export const Left = 'Left';
export function isLeft(item) {
    return reflection.isInstance(item, Left);
}
export const Right = 'Right';
export function isRight(item) {
    return reflection.isInstance(item, Right);
}
export const Clock = 'Clock';
export function isClock(item) {
    return reflection.isInstance(item, Clock);
}
export const ClockLeft = 'ClockLeft';
export function isClockLeft(item) {
    return reflection.isInstance(item, ClockLeft);
}
export class MyRobotAstReflection extends AbstractAstReflection {
    getAllTypes() {
        return ['Add', 'AddSubExpression', 'AddSubOperator', 'And', 'ArithmeticExpression', 'Backward', 'BooleanExpression', 'BooleanOperator', 'CallEntity', 'CallFunction', 'CallFunctionExpr', 'Clock', 'ClockLeft', 'ControlRobot', 'ControlStructure', 'Divise', 'Entity', 'EqualTo', 'Expression', 'Fonction', 'Forward', 'GetSensor', 'If', 'Left', 'Loop', 'LowerOrEqualTo', 'LowerThan', 'Movement', 'MultiDivExpression', 'MultiDivOperator', 'Multiply', 'Not', 'Or', 'Parameter', 'Program', 'ReturnType', 'Right', 'Rotate', 'SetSpeed', 'Statement', 'Sub', 'UnaryExpression', 'UpperOrEqualTo', 'UpperThan', 'Value', 'VariableAssignation', 'VariableStatement'];
    }
    computeIsSubtype(subtype, supertype) {
        switch (subtype) {
            case Add:
            case Sub: {
                return this.isSubtype(AddSubOperator, supertype);
            }
            case AddSubExpression: {
                return this.isSubtype(ArithmeticExpression, supertype);
            }
            case And:
            case EqualTo:
            case LowerOrEqualTo:
            case LowerThan:
            case Not:
            case Or:
            case UpperOrEqualTo:
            case UpperThan: {
                return this.isSubtype(BooleanOperator, supertype);
            }
            case ArithmeticExpression:
            case UnaryExpression: {
                return this.isSubtype(Expression, supertype);
            }
            case Backward:
            case Forward:
            case Left:
            case Right: {
                return this.isSubtype(Movement, supertype);
            }
            case CallEntity:
            case CallFunctionExpr:
            case GetSensor:
            case Value: {
                return this.isSubtype(UnaryExpression, supertype);
            }
            case CallFunction:
            case ControlRobot:
            case ControlStructure:
            case Entity:
            case SetSpeed:
            case VariableAssignation: {
                return this.isSubtype(Statement, supertype);
            }
            case Clock:
            case ClockLeft: {
                return this.isSubtype(Rotate, supertype);
            }
            case Divise:
            case Multiply: {
                return this.isSubtype(MultiDivOperator, supertype);
            }
            case If:
            case Loop: {
                return this.isSubtype(ControlStructure, supertype);
            }
            case Movement:
            case Rotate: {
                return this.isSubtype(ControlRobot, supertype);
            }
            case Parameter:
            case VariableStatement: {
                return this.isSubtype(Entity, supertype);
            }
            default: {
                return false;
            }
        }
    }
    getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'CallEntity:entity': {
                return Entity;
            }
            case 'CallFunction:function':
            case 'CallFunctionExpr:function': {
                return Fonction;
            }
            case 'VariableAssignation:variable': {
                return VariableStatement;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
    getTypeMetaData(type) {
        switch (type) {
            case 'Fonction': {
                return {
                    name: 'Fonction',
                    mandatory: [
                        { name: 'body', type: 'array' },
                        { name: 'parameter', type: 'array' }
                    ]
                };
            }
            case 'MultiDivExpression': {
                return {
                    name: 'MultiDivExpression',
                    mandatory: [
                        { name: 'operator', type: 'array' },
                        { name: 'rightOperand', type: 'array' }
                    ]
                };
            }
            case 'Program': {
                return {
                    name: 'Program',
                    mandatory: [
                        { name: 'function', type: 'array' }
                    ]
                };
            }
            case 'ArithmeticExpression': {
                return {
                    name: 'ArithmeticExpression',
                    mandatory: [
                        { name: 'arithmeticexpression', type: 'array' },
                        { name: 'rightOperand', type: 'array' }
                    ]
                };
            }
            case 'CallFunction': {
                return {
                    name: 'CallFunction',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'ControlStructure': {
                return {
                    name: 'ControlStructure',
                    mandatory: [
                        { name: 'condition', type: 'array' },
                        { name: 'expression', type: 'array' }
                    ]
                };
            }
            case 'AddSubExpression': {
                return {
                    name: 'AddSubExpression',
                    mandatory: [
                        { name: 'operator', type: 'array' }
                    ]
                };
            }
            case 'CallFunctionExpr': {
                return {
                    name: 'CallFunctionExpr',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'If': {
                return {
                    name: 'If',
                    mandatory: [
                        { name: 'else', type: 'array' },
                        { name: 'then', type: 'array' }
                    ]
                };
            }
            case 'Loop': {
                return {
                    name: 'Loop',
                    mandatory: [
                        { name: 'body', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}
export const reflection = new MyRobotAstReflection();
//# sourceMappingURL=ast.js.map